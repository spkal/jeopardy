---
title: Analysis of Jeopardy Games
author: Stephen Kaluzny
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r echo=FALSE}
jeopardyData <-readRDS("jeopardyData.rds")
```
This is an analysis of data about Jeopardy games that is avilable at http://www.j-archive.com/.
The data includes information mainly about the players: names, home city, number of agames played, winnings, etc.
This analysis does not look at the content of the game questions (answers). 

The Data
--------
### Getting the Data
The data was scraped from the http://www.j-archive.com site using an R function that was modified from https://scraperwiki.com/scrapers/jarchive_scraper_taiwanshaun/. The function, `jscrapeDirect`, is available in the appendix. Only regular Jeopardy games were downloaded, leaving out championships, teen, college, etc tournaments. The `id` argument is a vector of show id's to scrape from the web site.

To avoid having to get the data multiple times while developing the code, the `jscrapeDirect` function can be used in two steps. First call it with `getDataOnly=TRUE` to get the raw scraped data.  Then call `jscrapeDirect` with the raw data as an input (as the `data` argument) into a second call to `jscrapeDirect` to process the raw data.

```{r eval = FALSE}
jeopardyDataRaw <- jscrapeDirect(id=1:5000)
```

### Cleaning the Data
The raw scraped data has 7 columns:
```{r eval=FALSE}
names(jeopardyDataRaw)
```
The resulting data needs to be cleaned up.
Changes made include values in the wrong column,
fixing spelling of states,
New York city boroughs changed to New York,
"now living in ..." and "now stationed at ..."
changed to the listed location.
The cleaning was an iterative process,
looking at summaries of the data, finding more errors,
making corrections.
The clean up operations were all encapsulate in a single
function, `jcleanData` that could be repeatedly run on the
`jeopardyRawData` object.
The `jcleanData` function is listed in the appendix.

Creating the dataset:
```{r eval = FALSE}
jeopardyDataRaw <- jscrapeDirect(id=1:5000)
jeopardyData <- jcleanData(jeopardyDataRaw)
```
Added variables
 * GameMaxValue
 * Gender
 * PlayerId

Analysis
---------
The final dataset has `r nrow(jeopardyData)` rows and `r ncol(jeopardyData)` columns.
Each row represents a single player in a game,
each games consists of 3 rows
i,e, we have
`r nrow(jeopardyData)` player observations and
`r nrow(jeopardyData) / 3` games.
There are `r length(unique(jeopardyData$PlayerId))` different players.
The games were played from
`r min(jeopardyData$Date)` to `r max(jeopardyData$Date)`.

Final Winnings
--------------
```{r}
# name: winnings
require(dplyr)                                                      
summary(jeopardyData[jeopardyData$IsWinner, "FinalWinnings"])
group_by(jeopardyData, GameMaxValue) %>%
    summarize(MedianWinnings=median(FinalWinnings), 
       AveWinnings=mean(FinalWinnings))
```
```{r fig.width=8, fig.height=8}
require(ggplot2)
filter(jeopardyData, IsWinner) %>% 
    ggplot(aes(x=FinalWinnings)) +
    geom_histogram()
filter(jeopardyData, IsWinner) %>% 
    ggplot(aes(x=FinalWinnings)) +
    geom_histogram() +
    facet_grid(GameMaxValue ~ .)

# Number of wins
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins)) %>%
    filter(Wins > 1 & Wins < 19) %>%
    ggplot(aes(x=Wins)) +
        geom_bar(binwidth=0.5) +
        coord_flip()
#
# Dollar winnings per game
filter(jeopardyData, IsWinner) %>%
    filter(FinalWinnings < 60000) %>%
    ggplot(aes(x=FinalWinnings)) +
        geom_histogram()
# Total winnings per player:
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalWinnings)) %>%
    filter(Wins > 0) %>%
    filter( Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_jitter(position = position_jitter(width = .3))
# boxplot:    
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalWinnings)) %>%
    filter(Wins > 0) %>%
    filter(Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_boxplot(aes(group = Wins))
```

Players by State
----------------
To see if players are equally likely to come from any U.S. state, we want to compare the number of players from each state to the state's population.

State population data was downloaded from the U.S. Census
http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv.
The CSV file includes aggregation data at the top and population values for multiple years.
We only extracted the data for the 50 states and the District of Columbia and only used the 2010 values.
```{r censusdata}
URL <- "http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv"
censusTmpFile <- tempfile()
download.file(URL, destfile=censusTmpFile)
popPipe <- pipe(paste0("sed -n -e '/Alabama/,/Wyoming/p' ", censusTmpFile, " | cut -d'\"' --output-delimiter=\";\" -f1-2 | sed -e 's/\"//' -e 's/^.//' -e 's/,//g'"))
stateDF <- read.table(popPipe, sep=";", col.names=c("State", "Population"),
    stringsAsFactors=FALSE)
stateDF[stateDF$State == "District of Columbia", "State"] <- "D.C."
```
To stanbdardize, we computed the number of players per million people in a state:
```{r}
CountPlayersByState <- table(jeopardyData$State)
i51 <- match(stateDF$State, names(CountPlayersByState))
stateDF$NPlayers <- CountPlayersByState[i51]
stateDF$PlayersPerMillion <- with(stateDF, NPlayers/Population * 1e6)
```
Plots by state:
```{r}
require(ggplot2)
p1 <- ggplot(data=stateDF, aes(x=NPlayers,
    y=ordered(State, levels=State[order(stateDF$NPlayers)])))
p1 + geom_point() + xlab("Number of Players") + ylab("State")
p2 <- ggplot(data=stateDF, aes(x=log2(PlayersPerMillion),
    y=ordered(State, levels=State[order(stateDF$PlayersPerMillion)])))
p2 + geom_point()+ xlab("Number of Players / 1 Million Population") + ylab("State")
```
Appendix
-------------------------------------------------------
The web scraper function:
```{r eval=FALSE}
jscrapeDirect <- function(id, sleep=1, data=NULL, getDataOnly=FALSE){

  require("stringr", quietly=TRUE, warn.conflicts=FALSE, character.only=TRUE)
  if(is.null(data)) {
  require("XML", quietly=TRUE, warn.conflicts=FALSE, character.only=TRUE)
  require("reshape", quietly=TRUE, warn.conflicts=FALSE, character.only=TRUE)
  # Final table with (eventually) all shows
  d.jpdy <- data.frame()

  # Temporary table which will hold single show's data
  d.temp <- as.data.frame(matrix(NA,nrow=3,ncol=7))
  colnames(d.temp) <- c("Title","2","3","4","5","6","WebID")

  #THE PRE-GAME
  #Loop to determine which shows are tournaments
  #Also determines shows that have no data

  # THE GAME 
  # Loop that gets one show's data per iteration and aggregates it

  for ( k in id ) {

    url <- paste0("http://www.j-archive.com/showgame.php?game_id=",k)

    if(sleep > 0) Sys.sleep(sleep)
    doc <- try(htmlParse(url, error = function(...){}))

    r <- xmlRoot(doc)
    tables <- getNodeSet(doc, "//table")

    cat(k, "\n", file="k.txt", append=TRUE)
    
    # Create a vector of table lengths to help find the info we want
    vec <- rep(NA,length(llply(tables,names)))
    for (j in 1:length(llply(tables,names))){
      vec[j] <- length(names(tables[[j]]))
    }

    # Find the tables our info is in
    firstrd <- max(which(vec==6))-1
    secrd <- min(which(vec==3))
    finalrd <- length(vec)-1
    qcorr <- length(vec)

    # Scrape one show's data
    for (i in 0:2){
      d.temp[i+1,1] <- xmlValue(r[[1]][[1]])
      d.temp[i+1,2] <- xmlValue(tables[[1]][[1]][[3]][[2+2*i]])
      d.temp[i+1,3] <- xmlValue(tables[[firstrd]][[2]][[5-2*i]])
      d.temp[i+1,4] <- xmlValue(tables[[secrd]][[2]][[5-2*i]])
      d.temp[i+1,5] <- xmlValue(tables[[finalrd]][[2]][[5-2*i]])
      d.temp[i+1,6] <- xmlValue(tables[[qcorr]][[3]][[5-2*i]])
      d.temp[i+1,7] <- k
    }
    
    # Bind the show data to the final data frame
    d.jpdy <- rbind(d.jpdy, d.temp)

  }
  } else {
      d.jpdy <- data
  }
  if(getDataOnly) {
      return(d.jpdy)
  }

  # Extract and Format the Variables
  for (i in 1:dim(d.jpdy)[1]){

cat(i, d.jpdy[i,1], "WebID= ", d.jpdy[i,7], "\n", file="dinfo.txt", append=TRUE)

    personInfo <- d.jpdy[i,2]
    personInfoCommaIndex <- gregexpr(',', personInfo)
    # cat(i, personInfo, "\n", file="pi.txt", append=TRUE)
    occupationStart <- regexpr(' a ', personInfo)[1]
    nameEnd <- occupationStart - 2
    if(occupationStart == -1) {
        occupationStart <- regexpr(' an ', personInfo)[1] + 1
        if(occupationStart < 1) {
            nameEnd <- personInfoCommaIndex[[1]][1] - 1
        } else {
            nameEnd <- occupationStart - 3
        }
    }
    cityStart <- regexpr(' originally from ', personInfo)[1]
    fromLen <- 17
    if(cityStart == -1) {
        cityStart <- regexpr(' from ', personInfo)[1]
        fromLen <- 6
    }
    whoseStart <- regexpr('whose ', personInfo)[1]
    if(whoseStart == -1) {
        firstTime <- TRUE
        cityStateEnd <- nchar(personInfo)
    } else {
        cityStateEnd <- whoseStart - 3
    }
    d.jpdy$Name[i] <- substr(personInfo, 1, nameEnd)
    if(occupationStart < 1) {
        d.jpdy$Occupation[i] <- NA
    } else {
        d.jpdy$Occupation[i] <- substr(personInfo, occupationStart+3,
            cityStart-1)
    }
    cityState <- substr(personInfo, cityStart + fromLen, cityStateEnd)
    cityStateCommaIndex <- gregexpr(',', cityState)[[1]][1]
    if(cityStateCommaIndex == -1) {
        d.jpdy$City[i] <- NA
        d.jpdy$State[i] <- str_trim(cityState)
    } else {
        d.jpdy$City[i] <- str_trim(
            substr(cityState, 1, cityStateCommaIndex[[1]][1]-1))
        d.jpdy$State[i] <- str_trim(
            substr(cityState, cityStateCommaIndex[[1]][1]+1,
            nchar(cityState)))
    }
    if(nchar(d.jpdy$State[i]) == 0) {
        d.jpdy$State[i] <- NA
    }
    
    # Extract number of days on show
    e <- regexpr('whose', d.jpdy[i,2])[1]
    f <- regexpr('-day',d.jpdy[i,2])[1]
    if (e == -1) d.jpdy$num_times_on_show[i] <- 1 else{
      d.jpdy$num_times_on_show[i] <- as.numeric(substr(d.jpdy[i,2],e+6,f-1))+1
      }

    #######################
    ##Make numbers numeric
    ########################
    win1 <- gsub(',','', d.jpdy[i,3])
    d.jpdy$first_round_winnings[i] <- as.numeric(gsub('[$]','',win1))
    win2 <- gsub(',','', d.jpdy[i,4])
    d.jpdy$Winnings_2nd_Round[i] <- as.numeric(gsub('[$]','',win2))
    win3 <- gsub(',','', d.jpdy[i,5])
    d.jpdy$FinalWinnings[i] <- as.numeric(gsub('[$]','',win3))
    
    #################
    #Find Show
    #################
    place1 <- regexpr('#', d.jpdy[i,1])[1]
    place2 <- regexpr(',',d.jpdy[i,1])[1]
    show.temp <- substr(d.jpdy[i,1], place1, place2)
    show.temp <- gsub('#','',show.temp)
    d.jpdy$Show[i] <- as.numeric(gsub(',','',show.temp))

    #-----------------------------
    #Get Number Right
    d.jpdy$n.Right[i]<-as.numeric(strsplit(d.jpdy[i,6],' ')[[1]][1])
  
    #-----------------------------
    #Get Number Wrong
    w<-regexpr("W",d.jpdy[i,6])[1]-2
    c<-regexpr(",",d.jpdy[i,6])[1]+1
    d.jpdy$n.Wrong[i]<-as.numeric(substr(d.jpdy[i,6],c,w))

    #-----------------------------
    #Get Number DD Wrong
    str<-strsplit(d.jpdy[i,6],"W")[[1]][2]
    ddw<-regexpr("DD",str)[1]
    if (is.na(strsplit(d.jpdy[i,6],"W")[[1]][2])) {d.jpdy$DD.Wrong[i]<-0} 
    else {d.jpdy$DD.Wrong[i]<-as.numeric(substr(str,ddw-2,ddw-2))}

    #---------------------------
    #Get Number DD Right
    loc.c<-regexpr(",",d.jpdy[i,6])[1]
    loc.R<-regexpr("R",d.jpdy[i,6])[1]
    dds<-substr(d.jpdy[i,6],loc.R,loc.c)
    ddr<-regexpr("DD",dds)[1] 
    if (loc.c-loc.R < 2) {d.jpdy$DD.Right[i]<-0} 
    else {d.jpdy$DD.Right[i]<-as.numeric(substr(dds,ddr-2,ddr-2))}

  }

  d.jpdy <- d.jpdy[,-(2:6)]

  return(d.jpdy)

}
```
The data cleaning function:
```{r eval=FALSE}
"jcleanData"<-
function(df, dropPilot=TRUE, drop504=TRUE) {
    require("stringr", quietly=TRUE, warn.conflicts=FALSE, character.only=TRUE)
    # Nellis Air Force Base:
    indx <- which(df$City == "Nellis Air Force Base" &
        df$State == "Las Vegas")
    if(length(indx)) {
        df[indx, "City"] <- "Las Vegas"
        df[indx, "State"] <- "Nevada"
    }
    # State misspelled:
    indx <- which(df$State == "Vriginia")
    if(length(indx)) {
        df[indx, "State"] <- "Virginia"
    }
    indx <- which(df$State == "Nevade")
    if(length(indx)) {
        df[indx, "State"] <- "Nevada"
    }
    # State guess
    indx <- which(df$State == "Hawaii[?]")
    if(length(indx)) {
        df[indx, "State"] <- "Hawaii"
    }
    # Yellowstone National Park
    indx <- which(df$State == "Wyoming and Montana")
    if(length(indx)) {
        df[indx, "State"] <- "Wyoming"
    }
    # New York Boroughs
    indx <- which(df$State == "The Bronx")
    if(length(indx)) {
        df[indx, "City"] <- "New York"
        df[indx, "State"] <- "New York"
    }
    # New York City
    indx <- which(df$State == "New York City")
    if(length(indx)) {
        df[indx, "City"] <- "New York"
        df[indx, "State"] <- "New York"
    }
    # West Hartford, no state:
    indx <- which(df$State == "West Hartford")
    if(length(indx)) {
        df[indx, "City"] <- "West Hartford"
        df[indx, "State"] <- "Connecticut"
    }
    # now stationed at ... state
    indx <- grep("now stationed ", df$State)
    if(length(indx)) {
        for(i in indx) {
            stateFirstCommaIndex <- regexpr(',', df$State[i])[1]
            df$State[i] <- substr(df$State[i], 1, stateFirstCommaIndex - 1)
        }
    }
    # now living in ...
    indx <- grep("now living", df$State)
    if(length(indx)) {
        for(i in indx) {
            nowIndex <- regexpr('now living in ', df$State[i])
            newCityState <- substr(df$State[i], nowIndex[1] +
                attr(nowIndex, "match.length"), nchar(df$State[i]))
            cityStateCommaIndex <- gregexpr(',', newCityState)
            if(cityStateCommaIndex[[1]][1] == -1) {
                df$City[i] <- NA
                df$State[i] <- newCityState
            } else {
                df$City[i] <- str_trim(substr(newCityState, 1,
                    cityStateCommaIndex[[1]][1]-1))
                df$State[i] <- str_trim(substr(newCityState,
                    cityStateCommaIndex[[1]][1]+1, nchar(df$State[i])))
            }
        }
    }
    if(dropPilot) {
        indx <- grep("pilot", df$Title)
        if(length(indx)) {
            df <- df[-indx, ]
        }
    }
    if(drop504) {
        indx <- which(df$WebID == 504)
        if(length(indx)) {
            df <- df[-indx, ]
        }
    }
    df
}
```



