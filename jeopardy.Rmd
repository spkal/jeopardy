---
title: Analysis of Jeopardy Games
author: Stephen Kaluzny
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r echo=FALSE}
jeopardyDataRaw <- readRDS("jeopardyDataRaw.rds")
jeopardyData <- readRDS("jeopardyData.rds")
```
This is an analysis of data about Jeopardy games that is avilable at http://www.j-archive.com/.
The data includes information mainly about the players: names, home city, number of agames played, winnings, etc.
This analysis does not look at the content of the game questions (answers). 

The `dplyr` and `ggplot2` package will be used for the analysis
and are loaded here.

```{r}
library(ggplot2)
library(dplyr, quietly= TRUE, warn.conflicts = FALSE)
```

## The Data
### Getting the Data
The data was scraped from the http://www.j-archive.com site using an R function that was modified from https://scraperwiki.com/scrapers/jarchive_scraper_taiwanshaun/. The function, `jscrapeDirect`, is available in the appendix. Only regular Jeopardy games were downloaded, leaving out championships, teen, college, etc tournaments. The `id` argument is a vector of show id's to scrape from the web site.

To avoid having to get the data multiple times while developing the code, the `jscrapeDirect` function can be used in two steps. First call it with `getDataOnly=TRUE` to get the raw scraped data.  Then call `jscrapeDirect` with the raw data as an input (as the `data` argument) into a second call to `jscrapeDirect` to process the raw data.

```{r eval = FALSE}
jeopardyDataRaw <- jscrapeDirect(id=1:5000)
```

### Cleaning the Data
The raw scraped data has 15 columns:
```{r}
names(jeopardyDataRaw)
```

From these columns additional variables were computed.
Some variable were named to a consistent and descriptive naming scheme.

The resulting data needed to be cleaned up.
Changes made include values in the wrong column,
fixing spelling of states,
New York city boroughs changed to New York,
"now living in ..." and "now stationed at ..."
changed to the listed location.
The cleaning was an iterative process,
looking at summaries of the data, finding more errors,
making corrections.
The clean up operations were all encapsulate in a single
function, `jcleanData` that could be repeatedly run on the
`jeopardyRawData` object.
The `jcleanData` function is listed in the appendix.

### Additional Variables

To identify individual players, a `PlayerId` was created by pasting together the `Name`, `Occupation`, `City`, and `State`:

```{r eval = FALSE}
jeopardyData$PlayerId <- with(jeopardyData,
    paste(Name, Occupation, City, State, sep='.'))
```

A `Date` variable was extracted from information in the `Title` variable:

```{r eval = FALSE}
airedIndex <- regexpr(" aired ", jeopardyData$Title)
jeopardyData$Date <- as.Date(
    substr(jeopardyData$Title, airedIndex + 7, nchar(jeopardyData$Title)))
```

After November 23, 2001 the game doubled the dollar amounts for each answer.
A `GameMaxValue` was added to distinguish games before and after the change:

```{r eval = FALSE}
airedIndex <- regexpr(" aired ", jeopardyData$Title)
jeopardyData$Date <- as.Date(
    substr(jeopardyData$Title, airedIndex + 7, nchar(jeopardyData$Title)))
```

A variable, `IsWinner`, was added to identify the winner(s) in each game (tied final scores result in multiple winners):

```{r eval =FALSE}
isWinner <-
function (x)                                                                    
{
    r <- rank(x)
    if (all(r == 2)) {
        r <- c(4, 4, 4)
    }
    (r == 3) | (r == 2.5) | (r == 4)
}

jeopardyData <- group_by(jeopardyData, Show) %>%
    mutate(IsWinner = isWinner(FinalScore))
jeopardyData <- ungroup(jeopardyData)
```

The number of wins for each player was computed as:
```{r eval = FALSE}
jeopardyData <- group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1)
jeopardyData <- ungroup(jeopardyData)
```

### Gender

To analyze the results based on gender, the gender of each player needed to determined.
We used the `gender` package from CRAN.
The `gender` function from that package takes a first name and returns
the proportion of males and females with that name
(along with other attributes).
We use a cutoff proportion of `0.75` - if the proportion for a gender was
above the cutoff, we use that gender.
If it was less, we set the gender to `NA`.
To save computing time, we only compute the gender for the unique first names and then applied the results to all players.

```{r eval = FALSE}
library(gender)
firstName <- with(jeopardyData, gsub("^(.*?)\\s.*", "\\1", Name))
# Estimate gender using the gender from the gender package
# Only do the unique firstNames
uFirstName <- unique(firstName)
# This takes 232.14 secs on boulder:
uGenderList <- gender(uFirstName)
uGender <- sapply(uGenderList, function(x) x$gender)
#
# Code "male" -> "M", "female" -> "F"
uGender <- ifelse(uGender == "male", "M", uGender)
uGender <- ifelse(uGender == "female", "F", uGender)
uPropMale <- sapply(uGenderList, function(x) x$proportion_male)
uPropFemale <- sapply(uGenderList, function(x) x$proportion_female)
#
# Only consider gender that has prop. greater than propCutoff,
# otherwise, declare it as NA
propCutoff <- 0.75
uGender <- ifelse((!is.na(uGender) & uGender == "M" &
    uPropMale < propCutoff), NA, uGender)
uGender <- ifelse((!is.na(uGender) & uGender == "F" &
    uPropFemale < propCutoff), NA, uGender)
mFirstName <- match(firstName, uFirstName)
jeopardyData$Gender <- uGender[mFirstName]
```
We were able to predict gender for `r sum(!is.na(jeopardyData$Gender))`
players which is
`r round(sum(!is.na(jeopardyData$Gender)) / nrow(jeopardyData) * 100, 2)` percent.

The final dataset had 21 variables:
```{r}
names(jeopardyData)
```
## Analysis

The final dataset for analysi has
`r nrow(jeopardyData)` rows and `r ncol(jeopardyData)` columns.
Each row represents a single player in a game,
each games consists of 3 rows
i,e, we have
`r nrow(jeopardyData)` player observations and
`r nrow(jeopardyData) / 3` games.
There are `r length(unique(jeopardyData$PlayerId))` different players.
The games were played from
`r min(jeopardyData$Date)` to `r max(jeopardyData$Date)`.

### Within Games

The number of players in Final Jeopardy:
```{r}
NFinal <- jeopardyData %>%
    group_by(Show) %>%
    mutate(NumberInFinal = sum(SecondRoundScore > 0)) %>%
    summarise(NumberInFinal = first(NumberInFinal)) %>%
    with(table(NumberInFinal))
NFinal
# Percentage:
round(NFinal / sum(NFinal) * 100, 2)
```

#### Daily Doubles

There are 3 daily doubles in each game, one in the Jeopardy Round and
two in the Double Jeopardy round.
The player who gets the daily double questions 
can wager as much of their current score on the question.

The percentage of daily doubles that are answered correctly:

```{r}
TablePercentDDRight <- jeopardyData %>%
    filter(DDWrong + DDRight > 0) %>%
    mutate(PercentDDRight = DDRight / (DDWrong + DDRight)) %>%
    with(table(PercentDDRight))
names(TablePercentDDRight) <- c("0.0", "0.33", "0.50", "0.67", "1.00")
TablePercentDDRight
```

#### Runaways

A runaway game is when at least one player cannot be beat in Final
Jeopardy.
This will occur when one player has at least twice the score of each of the
other players.

```{r}
isRunaway <- function(score) {
    score <- sort(score)
    all(score[3] >= 2*score[-3])
}
jeopardyData %>%
    group_by(Show) %>%
    summarise(Runaway = isRunaway(SecondRoundScore)) %>%
    with(c(NumberRunaways=sum(Runaway),
        PercentRunaways=round(sum(Runaway) / length(Runaway) * 100, 2)))
```

How often did Ken Jennings win in a runaway?

```{r}
jeopardyData %>%
    group_by(Show) %>%
    filter("Ken Jennings.software engineer.Salt Lake City.Utah"
        %in% PlayerId, all(NumTimesOnShow < 75)) %>%
    summarise(Runaway = isRunaway(SecondRoundScore)) %>%
    with(c(NumberRunaways=sum(Runaway),
        PercentRunaways=round(sum(Runaway) / length(Runaway)  * 100, 2)))
```

### Final Winnings
```{r}
# name: winnings
summary(jeopardyData[jeopardyData$IsWinner, "FinalScore"])
filter(jeopardyData, IsWinner) %>%
    group_by(GameMaxValue) %>%
    summarize(MedianWinnings=median(FinalScore), 
       AveWinnings=mean(FinalScore))
```
```{r fig.width=8, fig.height=8}
filter(jeopardyData, IsWinner) %>% 
    ggplot(aes(x=FinalScore)) +
    geom_histogram()
filter(jeopardyData, IsWinner) %>% 
    ggplot(aes(x=FinalScore)) +
    geom_histogram() +
    facet_grid(GameMaxValue ~ .)

# Number of wins
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins)) %>%
    filter(Wins > 1 & Wins < 19) %>%
    ggplot(aes(x=Wins)) +
        geom_bar(binwidth=0.5) +
        coord_flip()
#
# Total winnings per player:
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalScore)) %>%
    filter(Wins > 0) %>%
    filter( Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_jitter(position = position_jitter(width = .3))
# boxplot:    
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalScore)) %>%
    filter(Wins > 0) %>%
    filter(Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_boxplot(aes(group = Wins))
```

## Players by State

To see if players are equally likely to come from any U.S. state, we want to compare the number of players from each state to the state's population.

State population data was downloaded from the U.S. Census
http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv.
The CSV file includes aggregation data at the top and population values for multiple years.
We only extracted the data for the 50 states and the District of Columbia and only used the 2010 values.
```{r censusdata}
URL <- "http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv"
censusTmpFile <- tempfile()
download.file(URL, destfile=censusTmpFile)
popPipe <- pipe(paste0("sed -n -e '/Alabama/,/Wyoming/p' ", censusTmpFile, " | cut -d'\"' --output-delimiter=\";\" -f1-2 | sed -e 's/\"//' -e 's/^.//' -e 's/,//g'"))
stateDF <- read.table(popPipe, sep=";", col.names=c("State", "Population"),
    stringsAsFactors=FALSE)
stateDF[stateDF$State == "District of Columbia", "State"] <- "D.C."
```
To stanbdardize, we computed the number of players per million people in a state:
```{r}
CountPlayersByState <- table(jeopardyData$State)
i51 <- match(stateDF$State, names(CountPlayersByState))
stateDF$NPlayers <- CountPlayersByState[i51]
stateDF$PlayersPerMillion <- with(stateDF, NPlayers/Population * 1e6)
```
Plots by state:
```{r}
require(ggplot2)
p1 <- ggplot(data=stateDF, aes(x=NPlayers,
    y=ordered(State, levels=State[order(stateDF$NPlayers)])))
p1 + geom_point() + xlab("Number of Players") + ylab("State")
p2 <- ggplot(data=stateDF, aes(x=log2(PlayersPerMillion),
    y=ordered(State, levels=State[order(stateDF$PlayersPerMillion)])))
p2 + geom_point()+ xlab("Number of Players / 1 Million Population") + ylab("State")
```
Appendix
-------------------------------------------------------

The web scraper function:
```{r eval=FALSE}
```
The data cleaning function:
```{r eval=FALSE}
```
