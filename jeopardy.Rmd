---
title: Analysis of Jeopardy Games
author: Stephen Kaluzny
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r echo=FALSE}
jeopardyDataRaw <- readRDS("jeopardyDataRaw.rds")
jeopardyData <- readRDS("jeopardyData.rds")
```

Jeopardy is a televison quiz show where three contestants compete by
responding to general knowledge clues.
Their responses must be in the form of a question.
The daily syndicated version of the show has been on the air since 1984.

This is an analysis of data about the Jeopardy games.
The data are available at http://www.j-archive.com/.
It includes information about the players: names, home city, number of games played, winnings, etc.
This analysis does not look at the content of the game questions (answers)
which are also available on the site.

These document is an exercise an example of data clean up, manipulation
and exploration using R, mostly with the `dplyr` and `ggplot2` packages.

The packages are loaded here.
```{r}
library(ggplot2)
library(dplyr, quietly= TRUE, warn.conflicts = FALSE)
```

## The Data
### Getting the Data
The data was scraped from the http://www.j-archive.com site using an R function that was modified from https://scraperwiki.com/scrapers/jarchive_scraper_taiwanshaun/. The function, `jscrapeDirect`, is available in the appendix. Only regular Jeopardy games were downloaded, leaving out championships, teen, college, etc tournaments. The `id` argument is a vector of show id's to scrape from the web site.

To avoid having to get the data multiple times while developing the code, the `jscrapeDirect` function can be used in two steps. First call it with `getDataOnly=TRUE` to get the raw scraped data.  Then call `jscrapeDirect` with the raw data as an input (as the `data` argument) into a second call to `jscrapeDirect` to process the raw data.

```{r eval = FALSE}
jeopardyDataRaw <- jscrapeDirect(id=1:5000)
```

### Cleaning the Data
The scraped data has 15 columns:
```{r}
names(jeopardyDataRaw)
```

From these columns additional variables were computed.
Variables were renamed to a consistent and descriptive naming scheme.

The resulting data needed to be cleaned up.
Changes made include values in the wrong column,
spelling error in names of cties and states,
New York city boroughs changed to New York,
"now living in ..." and "now stationed at ..."
changed to the listed location.
The cleaning was an iterative process,
looking at summaries of the data, finding more errors,
making corrections.
The clean up operations were all encapsulate in a single
function, `jcleanData` that could be repeatedly run on the
`jeopardyRawData` object.
The `jcleanData` function is listed in the appendix.

### Additional Variables
To identify individual players, a `PlayerId` was created by pasting together the `Name`, `Occupation`, `City`, and `State`:
```{r eval = FALSE}
jeopardyData$PlayerId <- with(jeopardyData,
    paste(Name, Occupation, City, State, sep='.'))
```
Analysis of `PlayerId` indicated that it uniquely identified players
e.g. show numbers and dates were grouped together.

A `Date` variable was extracted from information in the `Title` variable:

```{r eval = FALSE}
airedIndex <- regexpr(" aired ", jeopardyData$Title)
jeopardyData$Date <- as.Date(
    substr(jeopardyData$Title, airedIndex + 7, nchar(jeopardyData$Title)))
```

After November 23, 2001 the game doubled the dollar amounts for each answer.
A `GameMaxValue` variable was added to distinguish games before and after the change:

```{r eval = FALSE}
airedIndex <- regexpr(" aired ", jeopardyData$Title)
jeopardyData$Date <- as.Date(
    substr(jeopardyData$Title, airedIndex + 7, nchar(jeopardyData$Title)))
```

A variable, `IsWinner`, was added to identify the winner(s) in each game (tied final scores result in multiple winners):

```{r eval =FALSE}
isWinner <-
function (x)                                                                    
{
    r <- rank(x)
    if (all(r == 2)) {
        r <- c(4, 4, 4)
    }
    (r == 3) | (r == 2.5) | (r == 4)
}

jeopardyData <- group_by(jeopardyData, Show) %>%
    mutate(IsWinner = isWinner(FinalScore))
jeopardyData <- ungroup(jeopardyData)
```

The number of wins for each player was computed as:
```{r eval = FALSE}
jeopardyData <- group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1)
jeopardyData <- ungroup(jeopardyData)
```

### Gender
To analyze the results based on gender, the gender of each player needed to determined.
We used the `gender` package from CRAN.
The `gender` function from that package takes a first name and returns
the proportion of males and females with that name
(along with other attributes).
We use a cutoff proportion of `0.75` - if the proportion for a gender was
above the cutoff, we use that gender.
If it was less, we set the gender to `NA`.
To save computing time, we only compute the gender for the unique first names and then applied the results to all players.

```{r eval = FALSE}
library(gender)
firstName <- with(jeopardyData, gsub("^(.*?)\\s.*", "\\1", Name))
# Estimate gender using the gender from the gender package
# Only do the unique firstNames
uFirstName <- unique(firstName)
# This takes 232.14 secs on boulder:
uGenderList <- gender(uFirstName)
uGender <- sapply(uGenderList, function(x) x$gender)
#
# Code "male" -> "M", "female" -> "F"
uGender <- ifelse(uGender == "male", "M", uGender)
uGender <- ifelse(uGender == "female", "F", uGender)
uPropMale <- sapply(uGenderList, function(x) x$proportion_male)
uPropFemale <- sapply(uGenderList, function(x) x$proportion_female)
#
# Only consider gender that has prop. greater than propCutoff,
# otherwise, declare it as NA
propCutoff <- 0.75
uGender <- ifelse((!is.na(uGender) & uGender == "M" &
    uPropMale < propCutoff), NA, uGender)
uGender <- ifelse((!is.na(uGender) & uGender == "F" &
    uPropFemale < propCutoff), NA, uGender)
mFirstName <- match(firstName, uFirstName)
jeopardyData$Gender <- uGender[mFirstName]
```
We were able to predict gender for
`r with(jeopardyData, sum(!duplicated(PlayerId) & !is.na(jeopardyData$Gender)))`
players which is
`r round(with(jeopardyData, sum(!duplicated(PlayerId) & !is.na(jeopardyData$Gender)) / sum(!duplicated(PlayerId))) *100, 2)`
percent of the players.

The final dataset had 21 variables:
```{r}
names(jeopardyData)
```
## Analysis
The final dataset for analysi has
`r nrow(jeopardyData)` rows and `r ncol(jeopardyData)` columns.
Each row represents a single player in a game,
each games consists of 3 rows
i,e, we have
`r nrow(jeopardyData)` player observations and
`r nrow(jeopardyData) / 3` games.
There are `r length(unique(jeopardyData$PlayerId))` different players.
The games were played from
`r min(jeopardyData$Date)` to `r max(jeopardyData$Date)`.

#### Number of Games Played
The NumTimesOnShow variable increases each time the player is on the show.
We want to look at the maximum value of NumTimeOnShow for each player:
```{r}
jeopardyData %>%
    group_by(PlayerId) %>%
    mutate(MaxNumGames = max(NumTimesOnShow)) %>%
    with(summary(MaxNumGames))
```
Half the players only are on one show.
One player was on 75 times:
```{r}
jeopardyData %>%
    group_by(PlayerId) %>%
    mutate(MaxNumGames = max(NumTimesOnShow)) %>%
    filter(MaxNumGames == 75) %>%
    summarise(NumberWins = first(NumberWins))
```

```{r}
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins)) %>%
    filter(Wins > 1 & Wins < 19) %>%
    ggplot(aes(x=Wins)) +
        geom_bar(binwidth=0.5) +
        coord_flip()
```

Leaving out Jennings, and those that only played on game,
the number of games per player:
```{r}
jeopardyData %>%
    group_by(PlayerId) %>%
    summarize(MaxNumGames = max(NumTimesOnShow)) %>%
    filter(MaxNumGames < 75, MaxNumGames > 1) %>%
    ggplot(aes(x = MaxNumGames)) + geom_bar()
```

#### Number of Final Jeopardy Players
If a player has a score of 0 or less at the end of the double jeopardy round,
that player is eleminated from the final jeopardy round
The number of players in Final Jeopardy:
```{r}
NFinal <- jeopardyData %>%
    group_by(Show) %>%
    mutate(NumberInFinal = sum(SecondRoundScore > 0)) %>%
    summarise(NumberInFinal = first(NumberInFinal)) %>%
    with(table(NumberInFinal))
cbind(NumberOfPlayers=1:3, Count = NFinal, Percentage = round(NFinal / sum(NFinal) * 100, 2))
```

#### Daily Doubles
There are 3 daily doubles in each game, one in the Jeopardy Round and
two in the Double Jeopardy round.
The player who gets the daily double questions 
can wager as much of their current score on the question.

The number of daily doubles found by a player in a game:
```{r}
jeopardyData %>%
    mutate(DDCount = DDWrong + DDRight) %>%
    with(cbind(NumDD = 0:3, DDCount = table(DDCount),
       Percent =  round(table(DDCount) /  sum(table(DDCount)) * 100, 2))) 
```
The percentage of all daily doubles that are answered correctly is
`r 
jeopardyData %>%
    filter(DDWrong + DDRight > 0) %>%
    summarise(PercentDDRight = round(sum(DDRight) / sum(DDWrong + DDRight) * 100, 2))
`.

#### Runaways
A runaway game is when at least one player cannot be beat in Final
Jeopardy.
This will occur when one player has at least twice the score of each of the
other players.

```{r}
isRunaway <- function(score) {
    score <- sort(score)
    all(score[3] >= 2*score[-3])
}
jeopardyData %>%
    group_by(Show) %>%
    summarise(Runaway = isRunaway(SecondRoundScore)) %>%
    with(c(NumberRunaways=sum(Runaway),
        PercentRunaways=round(sum(Runaway) / length(Runaway) * 100, 2)))
```

How often did Ken Jennings win in a runaway?

```{r}
jeopardyData %>%
    group_by(Show) %>%
    filter("Ken Jennings.software engineer.Salt Lake City.Utah"
        %in% PlayerId, all(NumTimesOnShow < 75)) %>%
    summarise(Runaway = isRunaway(SecondRoundScore)) %>%
    with(c(NumberRunaways=sum(Runaway),
        PercentRunaways=round(sum(Runaway) / length(Runaway)  * 100, 2)))
```

#### Comebacks
How often does the player with the lowest score at the end of the double jeopardy round, win the game?

```{r}
jeopardyData %>%
    group_by(Show) %>%
    mutate(IsComeback = (SecondRoundScore == min(SecondRoundScore) &&
        IsWinner)) %>%
    with(table(IsComeback))
```

### Final Winnings
When looking at the dollar winnings we need to look separately
at games before the dollar values doubled and after.

```{r}
filter(jeopardyData, IsWinner) %>%
    group_by(GameMaxValue) %>%
    summarize(AveWinnings=mean(FinalScore),
        MedianWinnings=median(FinalScore))
```
The mean and median winnings are both about doubled
when the dollar amounts doubled.

The distribution of the winnings:
```{r fig.width=8, fig.height=8}
filter(jeopardyData, IsWinner) %>% 
    ggplot(aes(x=FinalScore)) +
    geom_histogram() +
    facet_grid(GameMaxValue ~ .)
```

##### Total winnings per player:

```{r}
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalScore)) %>%
    filter(Wins > 0) %>%
    filter( Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_jitter(position = position_jitter(width = .3))
# boxplot:    
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalScore)) %>%
    filter(Wins > 0) %>%
    filter(Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_boxplot(aes(group = Wins))
```

## Players by State

To see if players are equally likely to come from any U.S. state, we want to compare the number of players from each state to the state's population.

State population data was downloaded from the U.S. Census
http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv.
The CSV file includes aggregation data at the top and population values for multiple years.
We only extracted the data for the 50 states and the District of Columbia and only used the 2010 values.
```{r cache = TRUE}
URL <- "http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv"
censusTmpFile <- tempfile()
download.file(URL, destfile=censusTmpFile)
popPipe <- pipe(paste0("sed -n -e '/Alabama/,/Wyoming/p' ", censusTmpFile, " | cut -d'\"' --output-delimiter=\";\" -f1-2 | sed -e 's/\"//' -e 's/^.//' -e 's/,//g'"))
stateDF <- read.table(popPipe, sep=";", col.names=c("State", "Population"),
    stringsAsFactors=FALSE)
stateDF[stateDF$State == "District of Columbia", "State"] <- "D.C."
```
To stanbdardize, we computed the number of players per million people in a state:
```{r}
CountPlayersByState <- table(jeopardyData$State)
i51 <- match(stateDF$State, names(CountPlayersByState))
stateDF$NPlayers <- c(CountPlayersByState[i51])
stateDF$PlayersPerMillion <- with(stateDF, NPlayers/Population * 1e6)
```
Plots by state:
```{r}
p1 <- ggplot(data=stateDF, aes(x=NPlayers,
    y=ordered(State, levels=State[order(stateDF$NPlayers)])))
p1 + geom_point() + xlab("Number of Players") + ylab("State")
p2 <- ggplot(data=stateDF, aes(x=log2(PlayersPerMillion),
    y=ordered(State, levels=State[order(stateDF$PlayersPerMillion)])))
p2 + geom_point()+ xlab("Number of Players / 1 Million Population") + ylab("State")
stateDF %>%
  filter(State != "D.C.") %>%
  ggplot(aes(x=log2(PlayersPerMillion),
    y=ordered(State, levels=State[order(stateDF$PlayersPerMillion)]))) +
    geom_point()+ xlab("Number of Players / 1 Million Population") + ylab("State")
```

## Appendix

The web scraper function:
```{r eval=FALSE}
```
The data cleaning function:
```{r eval=FALSE}
```
