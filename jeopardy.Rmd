---
title: Analysis of Jeopardy Games
author: Stephen Kaluzny
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r echo=FALSE}
jeopardyDataRaw <- readRDS("jeopardyDataRaw.rds")
jeopardyData <- readRDS("jeopardyData.rds")
```

Jeopardy is a television quiz show where three contestants compete by
responding to general knowledge clues.
Their responses must be in the form of a question.
The daily syndicated version of the show has been on the air since 1984.

This paper is an analysis about data from the game show.

#### Game Description

The show has two rounds and a final.
Each round has 6 categories and within each category there are 5 clues.
The clues have increasing dollar amounts with a category.
If a player gives the correct answer to a clues, that dollar amount
is added to their score.
Incorrect answers result in subtraction of that dollar amount.

The final jeopardy clue ends the game.
The players are told the category and they can wager as much of their
score.
The players have 30 seconds to write down their response once the final clue
is shown.
Players with a correct response get their wager added to their score,
incorrect responses result in subtraction of the wager amount.
The player with the highest score wins that amount in dollars and
plays in the next day's game against two new players.

#### Purpose of This Analysis

Data from the Jeopary games are are available on the Internet.
It includes information about the players:
names, home city, number of games played, winnings, etc.
This analysis does not look at the content of the game questions (answers)
which are also available on the site.

This document is an example of data clean up, manipulation
and exploration using R, mostly with the `dplyr` and `ggplot2` packages.
The code for all of the data analysis is shown in the document.
The document is an example of a reproducible analysis.
All code to recreate the analysis, from getting the data,
cleaning it, to creating graphics is included.

The key packages are loaded here.
```{r}
library(ggplot2, quietly= TRUE, warn.conflicts = FALSE)
library(dplyr, quietly= TRUE, warn.conflicts = FALSE)
```

## The Data
### Getting the Data
The data was scraped from
the http://www.j-archive.com site
using an R function that was modified from
https://scraperwiki.com/scrapers/jarchive_scraper_taiwanshaun/.
The function, `jscrapeDirect`, is available in the Appendix.
Only regular Jeopardy games were downloaded,
leaving out championships, teen, college, etc tournaments.
The `id` argument is a vector of show id's to scrape from the web site.

To avoid having to get the data multiple times while developing the code,
the `jscrapeDirect` function can be used in two steps.
First call it with `getDataOnly=TRUE` to get the raw scraped data.
Then call `jscrapeDirect` with the raw data as an input
(as the `data` argument)
into a second call to `jscrapeDirect` to process the raw data.

```{r eval = FALSE}
jeopardyDataRaw <- jscrapeDirect(id=1:5000)
```

### Cleaning the Data
The scraped data has 15 columns:
```{r}
names(jeopardyDataRaw)
```

From these columns additional variables were computed.
Variables were renamed to a consistent and descriptive naming scheme.

The resulting data needed to be cleaned up.
Changes made include values in the wrong column,
spelling error in names of cities and states,
New York city boroughs changed to New York,
"now living in ..." and "now stationed at ..."
changed to the listed location.
The cleaning was an iterative process,
looking at summaries of the data, finding more errors,
making corrections.
The clean up operations were all encapsulate in a single
function, `jcleanData` that could be repeatedly run on the
`jeopardyRawData` object.
The `jcleanData` function is listed in the appendix.

### Additional Variables
To identify individual players, a `PlayerId` was created by pasting together the `Name`, `Occupation`, `City`, and `State`:
```{r eval = FALSE}
jeopardyData$PlayerId <- with(jeopardyData,
    paste(Name, Occupation, City, State, sep='.'))
```
Analysis of `PlayerId` indicated that it uniquely identified players
e.g. show numbers and dates were grouped together.

A `Date` variable was extracted from information in the `Title` variable:

```{r eval = FALSE}
airedIndex <- regexpr(" aired ", jeopardyData$Title)
jeopardyData$Date <- as.Date(
    substr(jeopardyData$Title, airedIndex + 7, nchar(jeopardyData$Title)))
```

After November 23, 2001 the game doubled the dollar amounts for each answer.
A `GameMaxValue` variable was added to distinguish games before and after the change:

```{r eval = FALSE}
airedIndex <- regexpr(" aired ", jeopardyData$Title)
jeopardyData$Date <- as.Date(
    substr(jeopardyData$Title, airedIndex + 7, nchar(jeopardyData$Title)))
```

A variable, `IsWinner`, was added to identify the winner(s) in each game (tied final scores result in multiple winners):

```{r eval =FALSE}
isWinner <-
function (x)                                                                    
{
    r <- rank(x)
    if (all(r == 2)) {
        r <- c(4, 4, 4)
    }
    (r == 3) | (r == 2.5) | (r == 4)
}
jeopardyData <- group_by(jeopardyData, Show) %>%
    mutate(IsWinner = isWinner(FinalScore))
jeopardyData <- ungroup(jeopardyData)
```

### Gender
To analyze the results based on gender,
the gender of each player needed to determined.
We used the `gender` package from CRAN.
The `gender` function from that package takes a first name and returns
the proportion of males and females with that name
(along with other attributes).
We use a cutoff proportion of `0.75` - if the proportion for a gender was
above the cutoff, we use that gender.
If it was less, we set the gender to `NA`.
To save computing time, we only compute the gender for the unique first names and then applied the results to all players.

```{r eval = FALSE}
library(gender)
firstName <- with(jeopardyData, gsub("^(.*?)\\s.*", "\\1", Name))
# Estimate gender using the gender from the gender package
# Only do the unique firstNames
uFirstName <- unique(firstName)
# This takes 232.14 secs on boulder:
uGenderList <- gender(uFirstName)
uGender <- sapply(uGenderList, function(x) x$gender)
#
# Code "male" -> "M", "female" -> "F"
uGender <- ifelse(uGender == "male", "M", uGender)
uGender <- ifelse(uGender == "female", "F", uGender)
uPropMale <- sapply(uGenderList, function(x) x$proportion_male)
uPropFemale <- sapply(uGenderList, function(x) x$proportion_female)
#
# Only consider gender that has prop. greater than propCutoff,
# otherwise, declare it as NA
propCutoff <- 0.75
uGender <- ifelse((!is.na(uGender) & uGender == "M" &
    uPropMale < propCutoff), NA, uGender)
uGender <- ifelse((!is.na(uGender) & uGender == "F" &
    uPropFemale < propCutoff), NA, uGender)
mFirstName <- match(firstName, uFirstName)
jeopardyData$Gender <- uGender[mFirstName]
```
We were able to predict gender for
`r with(jeopardyData, sum(!duplicated(PlayerId) & !is.na(jeopardyData$Gender)))`
players which is
`r round(with(jeopardyData, sum(!duplicated(PlayerId) & !is.na(jeopardyData$Gender)) / sum(!duplicated(PlayerId))) *100, 2)`
percent of the players.

The final dataset had 21 variables:
```{r}
names(jeopardyData)
```
## Analysis

The final dataset for analysis has
`r nrow(jeopardyData)` rows and `r ncol(jeopardyData)` columns.
Each row represents a single player in a game,
each games consists of 3 rows
i,e, we have
`r nrow(jeopardyData)` player observations and
`r nrow(jeopardyData) / 3` games.
There are `r length(unique(jeopardyData$PlayerId))` different players.
The games were played from
`r min(jeopardyData$Date)` to `r max(jeopardyData$Date)`.

### The Games

#### Answers

There are `6 categories x 5 clues x 2 rounds = 60` clues in each game.

Due to time limitations, the players may not get to all of the clues.
The number of clues attempted in a game by a single player is
the sum of the number correct (`NumRight`), the number wrong (`NumWrong`),
the number of daily doubles correct (`DDRight`)
and the number of daily doubles wrong (`DDWrong`).

```{r}
jeopardyData %>%
    group_by(Show) %>%
    mutate(NumAttempted = NumRight + NumWrong + DDWrong + DDRight) %>%
    with(summary(NumAttempted))
```

```{r fig.width=8, fig.height=8}
jeopardyData %>%
    group_by(Show) %>%
    mutate(NumAttempted = NumRight + NumWrong + DDWrong + DDRight) %>%
    ggplot(aes(x=factor(NumAttempted))) + 
        geom_bar() + xlab("Number Clues Attempted by a Player")                 
```

By gender:

```{r fig.width=8, fig.height=8}
jeopardyData %>%
    group_by(Show) %>%
    mutate(NumAttempted = NumRight + NumWrong + DDWrong + DDRight) %>%
    filter(!is.na(Gender)) %>%
    ggplot(aes(x=factor(NumAttempted))) + 
        geom_bar() + xlab("Number Clues Attempted by a Player") +
        facet_grid(Gender ~ .)
```

Note that the sum of `NumAttempted` across all three players in a game
is not the same as the total number of clues tried in that game
since after an incorrect response by a players,
another play can try to answer that same question.

The percentage of clues answers correctly by each player:

```{r}
jeopardyData %>%
    group_by(Show) %>%
    mutate(PercentCorrect =
        (NumRight + DDRight) / (NumRight + NumWrong + DDWrong + DDRight) * 100) %>%
    with(summary(PercentCorrect))
```

```{r fig.width=8, fig.height=8}
jeopardyData %>%
    group_by(Show) %>%
    mutate(PercentCorrect =
        (NumRight + DDRight) /
            (NumRight + NumWrong + DDWrong + DDRight) * 100) %>%
    ggplot(aes(x=PercentCorrect)) + 
        geom_histogram()
```

```{r fig.width=8, fig.height=8}
jeopardyData %>%
    group_by(Show) %>%
    mutate(PercentCorrect =
        (NumRight + DDRight) / (NumRight + NumWrong + DDWrong + DDRight) * 100,
        NumAttempted = NumRight + NumWrong + DDWrong + DDRight) %>%
    ggplot(aes(x=NumAttempted, y=PercentCorrect, color=Gender)) +
        geom_point() + geom_jitter(position=position_jitter(width=0.5, height=0.5))
```

#### Daily Doubles

There are 3 daily doubles in each game, one in the Jeopardy Round and
two in the Double Jeopardy round.
The player who gets the daily double questions 
can wager as much of their current score on the question.

The number of daily doubles found by a player in a game:
```{r}
jeopardyData %>%
    mutate(DDCount = DDWrong + DDRight) %>%
    with(cbind(NumDD = 0:3, DDCount = table(DDCount),
       Percent =  round(table(DDCount) /  sum(table(DDCount)) * 100, 2))) 
```
The percentage of all daily doubles that are answered correctly is
`r 
jeopardyData %>%
    filter(DDWrong + DDRight > 0) %>%
    summarise(PercentDDRight = round(sum(DDRight) / sum(DDWrong + DDRight) * 100, 2))
`.

#### Number of Final Jeopardy Players

If a player has a score of 0 or less at the end of the double jeopardy round,
that player is eliminated from the final jeopardy round
The number of players in Final Jeopardy:

```{r}
NFinal <- jeopardyData %>%
    group_by(Show) %>%
    mutate(NumberInFinal = sum(SecondRoundScore > 0)) %>%
    summarise(NumberInFinal = first(NumberInFinal)) %>%
    with(table(NumberInFinal))
cbind(NumberOfPlayers=1:3, Count = NFinal, Percentage = round(NFinal / sum(NFinal) * 100, 2))
```

#### Runaways

A runaway game is when at least one player cannot be beat in Final
Jeopardy.
This will occur when one player has at least twice the score of each of the
other players.

```{r}
isRunaway <- function(score) {
    score <- sort(score)
    all(score[3] >= 2*score[-3])
}
jeopardyData %>%
    group_by(Show) %>%
    summarise(Runaway = isRunaway(SecondRoundScore)) %>%
    with(c(NumberRunaways=sum(Runaway),
        PercentRunaways=round(sum(Runaway) / length(Runaway) * 100, 2)))
```

#### Ties
How often does the game end in a tie?

```{r}
NumWinners <-
function (x) {
    Winners <- 1
    r <- rank(x)
    if (all(r == 2)) {
        Winners <- 3
    }
    if(any(r == 2.5)) {
        Winners <- 2
    }
    Winners
}
jeopardyData %>%
    group_by(Show) %>%
    mutate(NumWinners = sum(IsWinner)) %>%
    summarise(NumWinners = first(NumWinners)) %>%
    with(cbind(Winners = 1:3, Count = table(NumWinners),
        Percent = round(table(NumWinners) / sum(NumWinners) * 100, 2)))
```

#### Comebacks

How often does the player with the lowest score
at the end of the double jeopardy round, win the game?

```{r}
jeopardyData %>%
    group_by(Show) %>%
    mutate(IsComeback = (SecondRoundScore == min(SecondRoundScore))) %>%
    filter(IsWinner) %>%
    with(c(Count = sum(IsComeback),
        Percent = round(sum(IsComeback) / length(IsComeback) * 100, 2)))
```

#### Dollar Winnings in a Game

When looking at the dollar winnings we need to look separately
at games before the dollar values doubled and after.

```{r}
jeopardyData %>%
    filter(IsWinner) %>%
    group_by(GameMaxValue) %>%
    summarize(AveWinnings=mean(FinalScore),
        MedianWinnings=median(FinalScore),
        MinWinnings=min(FinalScore),
        MaxWinnings=max(FinalScore)) %>%
    as.data.frame()
```

The mean and median winnings are both about doubled
when the dollar amounts doubled.

The shows where the winning score was 0:

```{r}
jeopardyData %>%
    filter(IsWinner, FinalScore == 0) %>%
    select(Date, Name, FinalScore) %>%
    as.data.frame()
```

In one game, all 3 players won with 0
and in another game, two players tied with a score of 0.

A visual view of the distribution of the winnings:

```{r fig.width=8, fig.height=8}
filter(jeopardyData, IsWinner) %>% 
    ggplot(aes(x=FinalScore)) +
    geom_histogram(binwidth = 2000) +
    facet_grid(GameMaxValue ~ .)
```

### The Players

#### Number of Games Played

The NumTimesOnShow variable increases each time the player is on the show.
We want to look at the maximum value of NumTimeOnShow for each player:

```{r}
jeopardyData %>%
    group_by(PlayerId) %>%
    mutate(MaxNumGames = max(NumTimesOnShow)) %>%
    with(summary(MaxNumGames))
```

Half the players only are on one show.
One player was on 75 times.
We will investigate that player later.

Looking at the players who won the most games:
```{r}
jeopardyData %>%
    group_by(PlayerId) %>%
    summarise(Name = first(Name), MaxNumGames = max(NumTimesOnShow)) %>%
    top_n(6, MaxNumGames) %>%
    select(Name, MaxNumGames) %>%
    arrange(desc(MaxNumGames))
 ```

The distribution of the number of games by a player,
leaving out the outliers (players who played more than 10 games)
as well as players who never won (i.e. only played one game):

```{r fig.width=8, fig.height=8}
jeopardyData %>%
    group_by(PlayerId) %>%
    summarise(MaxNumGames = max(NumTimesOnShow)) %>%
    filter(MaxNumGames > 1 & MaxNumGames < 11) %>%
    ggplot(aes(x=factor(MaxNumGames))) +
        geom_bar(binwidth=0.10) + xlab("NumGamesPlayed") +
        coord_flip()
```

#### Total Winnings Per Player 

Here we look at the total winnings for player over all the
games he or she played.
The number of wins is one less than the number of times on the show.
We use jitter to better visualize the data in each group:

```{r fig.width=8, fig.height=8}
group_by(jeopardyData, PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalScore)) %>%
    filter(Wins > 0) %>%
    filter( Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_jitter(position = position_jitter(width = .3))
```

Alternatively, we could use boxplots for the same data:

```{r fig.width=8, fig.height=8}
jeopardyData %>%
    group_by(PlayerId) %>%
    mutate(NumberWins = n() - 1) %>%
    summarise(Wins = first(NumberWins), Dollars = sum(FinalScore)) %>%
    filter(Wins > 0) %>%
    filter(Wins < 19) %>%
    ggplot(aes(x=Wins, y=Dollars)) +
        geom_boxplot(aes(group = Wins))
```

#### Gender

The gender of the
`r length(unique(jeopardyData$PlayerId))`
players:

```{r}
jeopardyData %>%
    group_by(PlayerId) %>%
    summarise(Gender1 = first(Gender)) %>%
    with(cbind(Count=table(Gender1),
        Percent=round(table(Gender1)/sum(table(Gender1)) * 100, 2)))
```

Here we look at the gender distribution for each game.
There are 4 possible combinations for the 3 contestants:
FFF, FFM, FMM, and MMM.
Since the winner plays in the next game,
the same player can contribute to many gender tryads.

To compute:

```{r}
trigen <- function(gen) {
    if(any(is.na(gen))) {
      NA_character_
    } else {
        paste0(sort(gen), collapse = "")
    }
}
jeopardyData %>%
    group_by(Show) %>%
    summarise(ShowGender = trigen(Gender)) %>%
    with(cbind(Count=table(ShowGender),
        Percent=round(table(ShowGender)/sum(table(ShowGender)) * 100, 2)))
```
A lot more games are played with two or more male contestants.

### Ken Jennings

The player with longest winning streak, 74 games
(the 75th game was loss):

```{r}
jeopardyData %>%
    group_by(PlayerId) %>%
    mutate(MaxNumGames = max(NumTimesOnShow)) %>%
    filter(MaxNumGames == 75) %>%
    summarise(NumberWins = n() - 1)
```

Ken Jennings won
`r filter(jeopardyData,
    PlayerId == "Ken Jennings.software engineer.Salt Lake City.Utah",
        NumTimesOnShow < 75) %>%
    summarise(TotalWinnings = sum(FinalScore)) %>%
    format(scientific = FALSE)`
in his 75 games.

The final scores in the game he lost:

```{r}
jeopardyData %>%
    group_by(Show) %>%
    filter("Ken Jennings.software engineer.Salt Lake City.Utah"
        %in% PlayerId, any(NumTimesOnShow == 75)) %>%
        ungroup() %>%
        select(Name, FinalScore) %>%
        arrange(desc(FinalScore))
```

His winnings by game:

```{r fig.width=8, fig.height=8}
filter(jeopardyData,
    PlayerId == "Ken Jennings.software engineer.Salt Lake City.Utah",
    NumTimesOnShow < 75) %>%
    ggplot(aes(x=Date, y=FinalScore)) + geom_point()
```

How often did Ken Jennings win in a runaway?

```{r}
jeopardyData %>%
    group_by(Show) %>%
    filter("Ken Jennings.software engineer.Salt Lake City.Utah"
        %in% PlayerId, all(NumTimesOnShow < 75)) %>%
    summarise(Runaway = isRunaway(SecondRoundScore)) %>%
    with(c(NumberRunaways=sum(Runaway),
        PercentRunaways=round(sum(Runaway) / length(Runaway)  * 100, 2)))
```

## Players by State

Where do Jeopardy players come from?
While there are players from countries other than the United States,
the vast majority are from the U.S.

To see if players are equally likely to come from any U.S. state,
we want to compare the number of players from each state
to the state's population.

State population data was downloaded from the U.S. Census
http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv.
The CSV file includes aggregation data at the top and population values
for multiple years.
We only extracted the data for the 50 states and the District of Columbia
and only used the 2010 values.

```{r cache = TRUE}
URL <- "http://www.census.gov/popest/data/state/totals/2012/tables/NST-EST2012-01.csv"
censusTmpFile <- tempfile()
download.file(URL, destfile=censusTmpFile)
popPipe <- pipe(paste0("sed -n -e '/Alabama/,/Wyoming/p' ", censusTmpFile, " | cut -d'\"' --output-delimiter=\";\" -f1-2 | sed -e 's/\"//' -e 's/^.//' -e 's/,//g'"))
stateDF <- read.table(popPipe, sep=";", col.names=c("State", "Population"),
    stringsAsFactors=FALSE)
stateDF[stateDF$State == "District of Columbia", "State"] <- "D.C."
```

To standardize, we computed the number of players per million people in a state:
```{r}
CountPlayersByState <- table(jeopardyData$State)
i51 <- match(stateDF$State, names(CountPlayersByState))
stateDF$NPlayers <- c(CountPlayersByState[i51])
stateDF$PlayersPerMillion <- with(stateDF, NPlayers/Population * 1e6)
```

Number of players per state;

```{r fig.width=8, fig.height=8}
ggplot(data=stateDF, aes(x=NPlayers,
    y=ordered(State, levels=State[order(stateDF$NPlayers)]))) +
    geom_point() +
    xlab("Number of Players") + ylab("State")
```

In general,
the bigger the state's population, the more players from that state.
Texas and Florida have the second and fourth largest population but
an low number of players and D.C. with a small population,
has a disproportionate number of players.

```{r fig.width=8, fig.height=8}
ggplot(data=stateDF, aes(x=Population, y=NPlayers)) + 
    geom_point() + xlab("State Population") +
    geom_text(data=subset(stateDF,
        State %in% c("New York", "D.C.", "Texas", "Florida")),
        aes(Population, NPlayers, label=State, vjust=1.3, hjust=0.2)) +
    geom_text(data=subset(stateDF,
        State %in% c("California")),
        aes(Population, NPlayers, label=State, vjust=1.3, hjust=0.8))
```

Number of players standardized by state's population (on log2 scale):

```{r fig.width=8, fig.height=8}
ggplot(data=stateDF, aes(x=log2(PlayersPerMillion),
    y=ordered(State, levels=State[order(stateDF$PlayersPerMillion)]))) +
    geom_point() +
    xlab("Number of Players / 1 Million Population") + ylab("State")
```

The same plot with `D.C.` left out:

```{r fig.width=8, fig.height=8}
stateDF %>%
  filter(State != "D.C.") %>%
  ggplot(aes(x=log2(PlayersPerMillion),
    y=ordered(State, levels=State[order(PlayersPerMillion)]))) +
    geom_point()+ xlab("Number of Players / 1 Million Population") + ylab("State")
```

## Appendix

The web scraper function:
```{r eval=FALSE}
```
The data cleaning function:
```{r eval=FALSE}
```
